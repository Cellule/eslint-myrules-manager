var path = require("path");
var fs = require("fs");
var async = require("async");
var utils = require("./utils");
var debug = utils.debug;
var modifiers = require("./modifiers");
var toArray = require("./utils/toArray");
var myrules = require("eslint-myrules");

var globalConfigPath = myrules.targetsPath.global;

function loadRulesObject(lintConfig, rulePath, target) {
  var rulesObj = {};
  if(fs.existsSync(rulePath)) {
    rulesObj = utils.readRules(rulePath);
  } else {
    debug("Unable to find rules %s for target %s", rulePath, target);
  }
  rulesObj = modifiers(rulesObj, lintConfig, target);
  rulesObj = utils.mergeConfigs(
    rulesObj,
    lintConfig.extraRules[target] || {}
  );
  return rulesObj;
}

function loadRules(lintConfig, rulePath, target, mergeTargets) {
  var rulesObj = loadRulesObject(lintConfig, rulePath, target);

  // Check if we merge any rules to the global target
  if(mergeTargets) {
    debug("Merging targets [%s] into target [%s]", mergeTargets, target);
    mergeTargets.forEach(function(mergeTarget) {
      if(typeof mergeTarget !== "string") {
        console.warn("Target to merge in global is invalid [%j]", mergeTarget);
        return;
      }
      var targetRulePath = myrules.targetsPath[mergeTarget];
      var rulesObjTarget = loadRulesObject(
        lintConfig,
        targetRulePath,
        mergeTarget
      );
      rulesObj = utils.mergeConfigs(rulesObj, rulesObjTarget);
    });

  }
  return "// DO NOT EDIT THIS FILE - USE eslint-myrules config\n" +
    utils.stringifyRules(rulesObj);
}


function copyRules(rootDir, lintConfig, doneCopying) {
  debug("Copying latest lint rules");
  var globalMergeTargets = toArray(lintConfig.mergeGlobal);
  var excludes = {global: true};
  globalMergeTargets.forEach(function(target) {
    excludes[target] = true;
  });
  // Copy all config files asynchronously
  async.parallel([
    function(callback) {
      var dst = path.resolve(rootDir, ".eslintrc");
      debug("Copying global rules to %s", dst);
      var rules = loadRules(
        lintConfig,
        globalConfigPath,
        "global",
        globalMergeTargets
      );
      // Copy global.eslintrc to //.eslintrc
      fs.writeFile(dst, rules, callback);
    },
    function(callback) {
      async.each(Object.keys(lintConfig.targets), function(target, nextTarget) {
        // Do not copy global rules in folder, eslint will look at root
        if(excludes[target]) {
          return nextTarget();
        }
        var thisTargetList = lintConfig.targets[target] || [];
        if(thisTargetList.length === 0) {
          return nextTarget();
        }
        var targetRulesPath = myrules.targetsPath[target];
        var rules = loadRules(lintConfig, targetRulesPath, target);

        async.each(lintConfig.targets[target], function(folder, nextFolder) {
          var folderPath = path.resolve(rootDir, folder);
          // Check if the folder exists
          fs.stat(folderPath, function(err, stat) {
            if(err) {
              var err2 = new Error(
                "Unable to find folder [%s] for target [%s]",
                folderPath,
                target
              );
              err2.err = err;
              err = err2;
            } else if(!stat.isDirectory() && !stat.isFile()) {
              err = new Error(
                "Item [%s] is neither a file nor a folder",
                folderPath
              );
            } else {
              if(stat.isFile()) {
                folderPath = path.dirname(folderPath);
              }
              var dst = path.resolve(folderPath, ".eslintrc");
              debug("Copying %s rules to %s", target, dst);
              // Copy target.eslintrc to /targetFolder/.eslintrc
              fs.writeFile(dst, rules, nextFolder);
              return;
            }
            nextFolder(err);
          });
        }, nextTarget);
      }, callback);
    }
  ], doneCopying);
}

module.exports = copyRules;
